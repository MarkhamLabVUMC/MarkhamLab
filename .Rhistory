shiny::runApp()
install.packages("shiny")
shiny::runApp()
library(shiny)
library(dplyr)
# Load your cleaned gene data
gene_data <- read.csv("C:\\Users\\anani\\Downloads\\ncbi_summaries_cleaned.csv")
# Define the UI
ui <- fluidPage(
titlePanel("Gene Description & Summary Chatbot"),
sidebarLayout(
sidebarPanel(
textInput("gene_list", "Enter Gene Symbols (comma-separated):", value = "BRCA1, TP53"),
checkboxGroupInput("info_type", "Select information to retrieve:",
choices = c("Description" = "description", "Summary" = "Summary"),
selected = "description"),
actionButton("submit", "Get Info"),
downloadButton("downloadData", "Download CSV")
),
mainPanel(
tableOutput("results")
)
)
)
# Define the server logic
server <- function(input, output) {
# Reactive expression to process the gene list and filter data
filtered_data <- reactive({
req(input$gene_list)
gene_list <- strsplit(input$gene_list, ",")[[1]]
gene_list <- trimws(gene_list) # Trim any white spaces
# Filter the data for the selected genes
result <- gene_data %>%
filter(Symbol %in% gene_list) %>%
select(Symbol, description, Summary)
# Filter the columns based on user selection
if ("description" %in% input$info_type & "Summary" %in% input$info_type) {
result <- result
} else if ("description" %in% input$info_type) {
result <- result %>% select(Symbol, description)
} else if ("Summary" %in% input$info_type) {
result <- result %>% select(Symbol, Summary)
}
return(result)
})
# Show the filtered data in the UI
output$results <- renderTable({
filtered_data()
})
# Download the filtered data as a CSV
output$downloadData <- downloadHandler(
filename = function() { "gene_info.csv" },
content = function(file) {
write.csv(filtered_data(), file, row.names = FALSE)
}
)
}
# Run the app
shinyApp(ui = ui, server = server)
# Load libraries
library(shiny)
library(dplyr)
# Load your cleaned gene data
gene_data <- read.csv("C:\\Users\\anani\\Downloads\\ncbi_summaries_cleaned.csv")
# Define the UI
ui <- fluidPage(
titlePanel("Gene Description & Summary Chatbot"),
sidebarLayout(
sidebarPanel(
textInput("gene_list", "Enter Gene Symbols (comma-separated):", value = "BRCA1, TP53"),
checkboxGroupInput("info_type", "Select information to retrieve:",
choices = c("Description" = "description", "Summary" = "Summary"),
selected = "description"),
actionButton("submit", "Get Info"),
downloadButton("downloadData", "Download CSV")
),
mainPanel(
tableOutput("results")
)
)
)
# Define the server logic
server <- function(input, output) {
# Reactive expression to process the gene list and filter data
filtered_data <- reactive({
req(input$gene_list)
gene_list <- strsplit(input$gene_list, ",")[[1]]
gene_list <- trimws(gene_list) # Trim any white spaces
# Filter the data for the selected genes
result <- gene_data %>%
filter(Symbol %in% gene_list) %>%
select(Symbol, description, Summary)
# Filter the columns based on user selection
if ("description" %in% input$info_type & "Summary" %in% input$info_type) {
result <- result
} else if ("description" %in% input$info_type) {
result <- result %>% select(Symbol, description)
} else if ("Summary" %in% input$info_type) {
result <- result %>% select(Symbol, Summary)
}
return(result)
})
# Show the filtered data in the UI
output$results <- renderTable({
filtered_data()
})
# Download the filtered data as a CSV
output$downloadData <- downloadHandler(
filename = function() { "gene_info.csv" },
content = function(file) {
write.csv(filtered_data(), file, row.names = FALSE)
}
)
}
# Run the app
shinyApp(ui = ui, server = server)
# Load libraries
library(shiny)
library(dplyr)
# Load your cleaned gene data
gene_data <- read.csv("C:\\Users\\anani\\Downloads\\ncbi_summaries_cleaned.csv")
# Define the UI
ui <- fluidPage(
titlePanel("Gene Description & Summary Chatbot"),
sidebarLayout(
sidebarPanel(
textInput("gene_list", "Enter Gene Symbols (comma-separated):", value = "BRCA1, TP53"),
checkboxGroupInput("info_type", "Select information to retrieve:",
choices = c("Description" = "description", "Summary" = "Summary"),
selected = "description"),
actionButton("submit", "Get Info"),
downloadButton("downloadData", "Download CSV")
),
mainPanel(
tableOutput("results")
)
)
)
# Define the server logic
server <- function(input, output) {
# Reactive expression to process the gene list and filter data
filtered_data <- reactive({
req(input$gene_list)
gene_list <- strsplit(input$gene_list, ",")[[1]]
gene_list <- trimws(gene_list) # Trim any white spaces
# Filter the data for the selected genes
result <- gene_data %>%
filter(Symbol %in% gene_list) %>%
select(Symbol, description, Summary)
# Filter the columns based on user selection
if ("description" %in% input$info_type & "Summary" %in% input$info_type) {
result <- result
} else if ("description" %in% input$info_type) {
result <- result %>% select(Symbol, description)
} else if ("Summary" %in% input$info_type) {
result <- result %>% select(Symbol, Summary)
}
return(result)
})
# Show the filtered data in the UI
output$results <- renderTable({
filtered_data()
})
# Download the filtered data as a CSV
output$downloadData <- downloadHandler(
filename = function() { "gene_info.csv" },
content = function(file) {
write.csv(filtered_data(), file, row.names = FALSE)
}
)
}
# Run the app
shinyApp(ui = ui, server = server)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:\\Analysis\\counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
# Create copy of counts matrix with gene names
counts_with_gene_names <- counts
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:\\Analysis\\10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
# Save for dashboard
saveRDS(dds, "D:\\Analysis\\Dashboard\\dds_results.rds")
# Set row names of 'metadata' to the 'Sample' column values
rownames(metadata) <- paste0("sample", sprintf("%04d", as.integer(rownames(metadata))))
# Get raw counts from DESeqDataSet object
raw_counts <- counts(dds)
library(ggplot2)
# Iterate over each unique condition
for (condition in unique(metadata$Condition)) {
# Subset sample names for the current condition
samples_in_condition <- rownames(metadata)[metadata$Condition == condition]
# Subset counts for samples in the current condition
counts_in_condition <- raw_counts[, samples_in_condition]
# Calculate the sum of counts per gene across all samples in the condition
gene_counts_sum <- rowSums(counts_in_condition)
average_counts_per_condition <- data.frame()
# Pre-filtering
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]
# Differential Expression Analysis
# Run the DESeq pipeline
dds <- DESeq(dds)
res <- results(dds)
res
saveRDS(res, "D:\\Analysis\\Dashboard\\results_table.rds")  # Save the DESeq2 results table
library(apeglm)
# 4. LFC
# Log fold change shrinkage for visualization and ranking
resultsNames(dds)
# First, find the position of "Condition_TcdB.A_vs_Untreated" in the resultsNames(dds)
coefPosition <- which(resultsNames(dds) == "Condition_TcdB.A_vs_Untreated")
# Now use this position with lfcShrink
resLFC <- lfcShrink(dds, coef=coefPosition, type="apeglm")
resLFC
library("BiocParallel")
# For windows, use SnowParam, not MulticoreParam: register(MulticoreParam(4))
register(SnowParam(4))
# 6. p-values & adjusted p-values
resOrdered <- res[order(res$pvalue),]
summary(res)
# Shows how many adjusted p-values were less than 0.1
sum(res$padj < 0.1, na.rm=TRUE)
res05 <- results(dds, alpha=0.05)
summary(res05)
sum(res05$padj < 0.05, na.rm=TRUE)
library("IHW")
resIHW <- results(dds, filterFun=ihw)
summary(resIHW)
sum(resIHW$padj < 0.1, na.rm=TRUE)
metadata(resIHW)$ihwResult
# Create interactive MA plot
ma_plot_interactive <- plotMA(res, ylim=c(-2,2), returnData=TRUE)
# Convert it to ggplot for compatibility with plotly
ma_plot_gg <- ggplot(ma_plot_interactive, aes(x = mean, y = lfc)) +
geom_point(aes(color = isDE)) +
theme_minimal() +
labs(title = "MA Plot", x = "Mean Expression", y = "Log2 Fold Change")
# Convert to plotly for interactivity
ma_plotly <- ggplotly(ma_plot_gg)
# Save the interactive plot as HTML
htmlwidgets::saveWidget(ma_plotly, "ma_plot_interactive.html")
# Create interactive MA plot
ma_plot_interactive <- plotMA(res, ylim=c(-2,2), returnData=TRUE)
# Convert it to ggplot for compatibility with plotly
ma_plot_gg <- ggplot(ma_plot_interactive, aes(x = mean, y = lfc)) +
geom_point(aes(color = isDE)) +
theme_minimal() +
labs(title = "MA Plot", x = "Mean Expression", y = "Log2 Fold Change")
# Convert to plotly for interactivity
ma_plotly <- ggplotly(ma_plot_gg)
# Save the interactive plot as HTML
htmlwidgets::saveWidget(ma_plotly, "D:\\Analysis\\Dashboard\\ma_plot_interactive.html")
getwd()
getwd()
MA_plot <- plotMA(res, ylim=c(-2,2))
counts
View(counts)
shiny::runApp()
