resultsNames(dds)
resNorm <- lfcShrink(dds, coef=2, type="normal")
resAsh <- lfcShrink(dds, coef=2, type="ashr")
plotCounts(dds, gene=which.min(res$padj), intgroup="Condition")
d <- plotCounts(dds, gene=which.min(res$padj), intgroup="Condition",
returnData=TRUE)
library("ggplot2")
ggplot(d, aes(x=Condition, y=count)) +
geom_point(position=position_jitter(w=0.1,h=0)) +
scale_y_log10(breaks=c(25,100,400))
mcols(res)$description
mcols(res)$description
vsd <- vst(dds, blind=FALSE)
rld <- rlog(dds, blind=FALSE)
head(assay(vsd), 3)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
# this gives log2(n + 1)
ntd <- normTransform(dds)
library("vsn")
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Cells")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:200]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=TRUE,
cluster_cols=FALSE, annotation_col=df)
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Cell")])
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20000]
df <- as.data.frame(colData(dds)[,c("Condition","Cell")])
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:200]
df <- as.data.frame(colData(dds)[,c("Condition","Cell")])
library("pheatmap")
select <- order(rowMeans(counts(dds,normalized=TRUE)),
decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds)[,c("Condition","Round")])
pheatmap(assay(ntd)[select,], cluster_rows=FALSE, show_rownames=FALSE,
cluster_cols=FALSE, annotation_col=df)
# this gives log2(n + 1)
ntd <- normTransform(dds)
library("vsn")
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))
BiocManager::install("DESeq2")
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:/Analysis/counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:/Analysis/10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
# Convert counts to a binary presence/absence (expressed/not expressed)
expressed_genes <- counts(dds) > 0
expressed_genes_summary <- colSums(expressed_genes)
# Add condition information
expressed_genes_df <- data.frame(Sample = names(expressed_genes_summary),
NumExpressedGenes = expressed_genes_summary,
Condition = metadata$Condition[names(expressed_genes_summary)])
library(ggplot2)
ggplot(expressed_genes_df, aes(x = Condition, y = NumExpressedGenes, fill = Condition)) +
geom_bar(stat = "identity", position = position_dodge()) + # Use dodge to avoid bars overlapping
theme_minimal() +
labs(x = "Condition", y = "Number of Expressed Genes", title = "Expressed Genes by Condition") +
scale_fill_brewer(palette = "Set1") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Rotate x labels for clarity
# Add condition information
expressed_genes_df <- data.frame(Sample = names(expressed_genes_summary),
NumExpressedGenes = expressed_genes_summary,
Condition = metadata$Condition[names(expressed_genes_summary)])
View(expressed_genes_df)
# Rename the sample names in the counts data to match the metadata, if necessary
colnames(counts) <- gsub("sample", "sample_", colnames(counts))
# Now let's ensure the rownames of metadata match the corrected column names of counts
rownames(metadata) <- metadata$Sample
# Check if the sample names match now
all(colnames(counts) %in% rownames(metadata)) # Should return TRUE if all names match
# Histogram of counts of genes by condition
library("ggplot2")
library("dplyr")  # for data manipulation
# Generate a temporary metadata dataframe for plotting
temp_metadata <- metadata
temp_metadata$Sample <- gsub("_", "", temp_metadata$Sample) # Remove underscores for matching
# 2.
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:/Analysis/counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:/Analysis/10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
library("ggplot2")
library("dplyr")  # for data manipulation
# Generate a temporary metadata dataframe for plotting
temp_metadata <- metadata
temp_metadata$Sample <- gsub("_", "", temp_metadata$Sample) # Remove underscores for matching
temp_metadata
colnames(metadata)
# Summarize the counts to get the number of expressed genes per sample
# Assuming 0 indicates no expression
expressed_genes <- counts > 0
expressed_genes_summary <- colSums(expressed_genes)
# Prepare a data frame for the plot
plotting_df <- data.frame(Sample = names(expressed_genes_summary),
NumExpressedGenes = expressed_genes_summary)
# Ensure the row names of metadata are used as a matching column for the merge
metadata_for_plot <- cbind(Sample = rownames(metadata), metadata)
# Merge the counts summary with the corrected metadata for plotting
plotting_df <- merge(plotting_df, metadata_for_plot, by = "Sample")
# Now you can plot the histogram for each condition
# Note: Replace `Condition` with the actual column name in your metadata if different
ggplot(plotting_df, aes(x = NumExpressedGenes, fill = Condition)) +
geom_histogram(binwidth = 100, position = "identity", alpha = 0.7) +
facet_wrap(~ Condition, scales = "free_y") +
theme_minimal() +
labs(x = "Number of Expressed Genes", y = "Frequency", title = "Distribution of Expressed Genes by Condition") +
scale_fill_brewer(palette = "Set1") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Summarize the counts to get the number of expressed genes per sample
# Assuming 0 indicates no expression
expressed_genes <- counts > 0
expressed_genes_summary <- colSums(expressed_genes)
# Prepare a data frame for the plot
plotting_df <- data.frame(Sample = names(expressed_genes_summary),
NumExpressedGenes = expressed_genes_summary)
# Ensure the row names of metadata are used as a matching column for the merge
metadata_for_plot <- cbind(Sample = rownames(metadata), metadata)
# Merge the counts summary with the corrected metadata for plotting
plotting_df <- merge(plotting_df, metadata_for_plot, by = "Sample")
# After the merge, check if the Condition column has been properly filled
print(head(plotting_df$Condition))
# If the above returns only NA, then the merge was not successful. Check the sample names:
print(head(plotting_df$Sample))
print(head(metadata_for_plot$Sample))
# If you find discrepancies, you may need to use sub or gsub to make them match
# For example, if `metadata_for_plot` has underscores and `plotting_df` doesn't:
metadata_for_plot$Sample <- gsub("_", "", metadata_for_plot$Sample)
# Try merging again after correcting sample names
plotting_df <- merge(plotting_df, metadata_for_plot, by = "Sample")
# Check again if the Condition column is now properly filled
print(head(plotting_df$Condition))
g.trt <- c(94, 197, 16, 38, 99, 141, 23)
g.ctr <- c(52, 104, 146, 10, 51, 30, 40, 27, 46)
N  =  400
sumorig  =  sum(g.trt)
n  =  length(g.trt)
cnt =  0
A  =  c(g.trt,g.ctr)
for  (i  in  1:N){
D  =  sample  (A,n)
if  (sum(D)  <=  sumorig)cnt  =  cnt+1  }
cnt/N
N = 1000
n = length(g.ctr)
m = length(g.trt)
stat = numeric(N)
for (i in 1:N){
g.ctrB = sample(g.ctr, n, replace = T )
g.trtB = sample(g.trt, m, replace = T )
stat[i] = mean(g.trtB) - mean(g.ctrB)
}
quantile(stat, probs = c(0.125, 0.875))
control <- c(4, 6, 3, 4, 7, 6)
treated <- c(14, 6, 3, 12, 7, 15)
t.test(control, treated, "l")
control <- c(4, 6, 3, 4, 7, 6)
treated <- c(14, 6, 3, 12, 7, 15)
t.test(control, treated)
qbinom(0.05, size = 10, prob = 0.5, lower.tail = FALSE) #8
pbinom(8, size = 10, prob = 0.75, lower.tail = FALSE)#0.2440252
# 2.
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:/Analysis/counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
# Create copy of counts matrix with gene names
counts_with_gene_names <- counts
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:/Analysis/10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
# Histogram of counts per condition
# Set row names of 'metadata' to the 'Sample' column values
rownames(metadata) <- paste0("sample", sprintf("%04d", as.integer(rownames(metadata))))
library(ggplot2)
# Get raw counts from DESeqDataSet object
raw_counts <- counts(dds)
# Iterate over each unique condition
for (condition in unique(metadata$Condition)) {
# Subset sample names for the current condition
samples_in_condition <- rownames(metadata)[metadata$Condition == condition]
# Subset counts for samples in the current condition
counts_in_condition <- raw_counts[, samples_in_condition]
# Calculate the sum of counts per gene across all samples in the condition
gene_counts_sum <- rowSums(counts_in_condition)
# Plot histogram of gene counts sum for the current condition
p <- ggplot(data = data.frame(gene_counts_sum), aes(x = gene_counts_sum)) +
geom_histogram(bins = 3, fill = "blue", color = "black") +
ggtitle(paste("Histogram of gene counts for", condition)) +
xlab("Sum of counts per gene") +
ylab("Number of genes")
print(p)
}
# Line Graph
library(ggplot2)
library(dplyr)
# Calculate average count per gene for each condition
average_counts_per_condition <- data.frame()
for (condition in unique(metadata$Condition)) {
samples_in_condition <- rownames(metadata)[metadata$Condition == condition]
counts_in_condition <- raw_counts[, samples_in_condition]
# Calculate the average count per gene
average_counts <- rowMeans(counts_in_condition)
# Prepare a data frame for plotting
condition_data <- data.frame(Gene = 1:nrow(raw_counts),
AverageCount = average_counts,
Condition = condition)
average_counts_per_condition <- rbind(average_counts_per_condition, condition_data)
}
# Open a PNG device
png("D:\\Analysis\\average_gene_counts_by_condition.png", width = 800, height = 600)
# Plot
ggplot(average_counts_per_condition, aes(x = Gene, y = AverageCount, color = Condition)) +
geom_line() +
theme_minimal() +
labs(title = "Average Gene Counts by Condition", x = "Gene (ordered by appearance)", y = "Average Count") +
scale_color_brewer(palette = "Set1") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Close the device
dev.off()
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:/Analysis/counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
# Create copy of counts matrix with gene names
counts_with_gene_names <- counts
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:/Analysis/10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
# 2. Pre-filtering
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]
# 3. Differential Expression Analysis
# Run the DESeq pipeline
dds <- DESeq(dds)
res <- results(dds)
res
library(apeglm)
# 4. LFC
# Log fold change shrinkage for visualization and ranking
resultsNames(dds)
# First, find the position of "Condition_TcdB.A_vs_Untreated" in the resultsNames(dds)
coefPosition <- which(resultsNames(dds) == "Condition_TcdB.A_vs_Untreated")
# Now use this position with lfcShrink
resLFC <- lfcShrink(dds, coef=coefPosition, type="apeglm")
resLFC
vsd <- vst(dds, blind=FALSE)
rld <- rlog(dds, blind=FALSE)
head(assay(vsd), 3)
# PCA Plot
# Saved as PCA_Plot_Samples
plotPCA(vsd, intgroup=c("Condition", "Cells"))
pcaData <- plotPCA(vsd, intgroup=c("Condition", "Cells"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=condition, shape=type)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()
pcaData <- plotPCA(vsd, intgroup=c("Condition", "Cells"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Condition, shape=Cells)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()
# Open a PNG device
png("D:\\Analysis\\PCA_Plot_Samples_Customized.png", width = 800, height = 600)
pcaData <- plotPCA(vsd, intgroup=c("Condition", "Cells"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Condition, shape=Cells)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()
# Close the device
dev.off()
# Open a PNG device
png("D:\\Analysis\\PCA_Plot_Samples_Customized.png", width = 1000, height = 1000)
pcaData <- plotPCA(vsd, intgroup=c("Condition", "Cells"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Condition, shape=Cells)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()
# Close the device
dev.off()
# Open a PNG device
png("D:\\Analysis\\PCA_Plot_Samples_Customized.png", width = 800, height = 600)
pcaData <- plotPCA(vsd, intgroup=c("Condition", "Cells"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=Condition, shape=Cells)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()
# Close the device
dev.off()
knitr::opts_chunk$set(echo = TRUE)
model <- lm(tuition~salary)
tuition = c(28540, 40133, 39900, 0, 0, 42050, 43220, 39565, 40400, 54506)
salary = c(137, 135, 127, 122, 120, 118, 118, 117, 117, 114)
plot(tuition, salary)
model <- lm(tuition~salary)
resid(lm(tuition~salary))
pred = lm(tuition~salary)
plot(salary, tuition, lines(salary, fitted(pred)))
# Plot residuals
residuals <- residuals(model)
plot(tuition, residuals, main="Residuals Plot",
xlab="Salary", ylab="Residuals (Tuition)",
pch=19, col="blue")
abline(h=0, col="red", lty=2)  # Adds a horizontal line at zero
library("DESeq2")
library(readr)  # for read_csv
# Load counts matrix
counts_file_path <- "D:/Analysis/counts_matrix.csv"
counts <- read_csv(counts_file_path, col_names = TRUE)
rownames(counts) <- counts$...1 # Replace '...1' with the actual name of the gene ID column if necessary
# Create copy of counts matrix with gene names
counts_with_gene_names <- counts
counts <- counts[,-1] # Drop the gene ID column so that only numeric count data remains
# Load metadata
metadata_file_path <- "D:/Analysis/10051_NM_metadata.csv"
metadata <- read_csv(metadata_file_path)
rownames(metadata) <- metadata$Sample
metadata <- metadata[,-1] # Remove the 'Sample' column after setting it as row names
# Rename rownames in metadata to match the column names in counts
rownames(metadata) <- colnames(counts)
# Check that the sample names in the counts matrix and metadata match
stopifnot(all(colnames(counts) == rownames(metadata)))
# which contains the conditions for each sample
metadata$Condition <- factor(metadata$Condition,
levels = c("Untreated", "TcdB", "TcsL", "H2O2", "Vehicle", "TcdA", "TcdB+A"))
# Now 'Untreated' is the first level and thus the reference level by default
# If you want to explicitly set it as the reference you can use relevel
metadata$Condition <- relevel(metadata$Condition, ref = "Untreated")
# Create the DESeqDataSet object
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = DataFrame(metadata),
design = ~ Condition) # Replace 'Condition' with the actual condition variable name if different
# Differential Expression Analysis
# Run the DESeq pipeline
dds <- DESeq(dds)
res <- results(dds)
res
# Assigning row names from counts_with_gene_names to res
rownames(res) <- rownames(counts_with_gene_names)
# Now, create the gene mapping again
res$gene <- counts_with_gene_names$...1  # Adjust the column name as needed
# Check if any gene names are missing after assignment
if (any(is.na(res$gene))) {
stop("Some gene names could not be found. Please check the data.")
} else {
message("Gene names successfully merged!")
}
# Check the head of res to ensure correctness
head(res)
library(EnhancedVolcano)
# Create the volcano plot using EnhancedVolcano
png("D:\\Analysis\\volcano_plot_unlabeled.png", width = 1200, height = 600)
EnhancedVolcano(res,
lab = res$gene,
x = 'log2FoldChange',
y = 'pvalue',
title = 'Volcano plot',
pCutoff = 0.05,  # General p-value cutoff for significance highlighting
FCcutoff = 2,    # General fold change cutoff for significance highlighting
pointSize = 2.0,
labSize = 3.0,
labCol = 'black',
colAlpha = 0.8,
drawConnectors = TRUE,
selectLab = res$pvalue < 0.01 & abs(res$log2FoldChange) > 2.5)  # More stringent criteria for labeling
dev.off()
# Load necessary libraries
library(ggplot2)
library(ggrepel)  # For better label placement
# Prepare the data for plotting
res$logP <- -log10(res$pvalue)  # Create a new column for the transformed p-values
res$significant <- res$pvalue < 0.05 & abs(res$log2FoldChange) > 1  # Define significance
res$logP
